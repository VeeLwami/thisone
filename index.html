<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maze Game with Walls</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
        }

        #maze-container {
            position: relative;
            width: 90vmin;
            height: 90vmin;
            border: 2px solid #000;
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            grid-template-rows: repeat(10, 1fr);
            background-color: #fff;
            box-sizing: border-box;
        }

        .cell {
            box-sizing: border-box;
        }

        #ball {
            position: absolute;
            width: 9vmin;
            height: 9vmin;
            background-color: red;
            border-radius: 50%;
            box-sizing: border-box;
        }

        .wall {
            position: absolute;
            width: 9vmin;
            height: 9vmin;
            background-color: #000;
            box-sizing: border-box;
        }

        .goal {
            position: absolute;
            width: 9vmin;
            height: 9vmin;
            background-color: green;
            opacity: 0.5;
            box-sizing: border-box;
        }
    </style>
</head>
<body>
    <div id="maze-container">
        <div id="ball"></div>
    </div>
    <script>
        const ball = document.getElementById('ball');
        const mazeContainer = document.getElementById('maze-container');
        const mazeSize = 10;
        const cellSize = 9;

        let ballPosition = { x: 0, y: 0 };
        let velocity = { x: 0, y: 0 };
        let friction = 0.98;
        let sensitivity = 0.009;

        const maze = [
            [0, 1, 0, 0, 0, 0, 1, 0, 0, 0],
            [0, 1, 0, 1, 1, 0, 1, 0, 1, 0],
            [0, 1, 0, 1, 0, 0, 1, 0, 1, 0],
            [0, 0, 0, 1, 0, 1, 0, 0, 1, 0],
            [1, 1, 0, 1, 0, 1, 0, 1, 1, 0],
            [0, 0, 0, 0, 0, 0, 0, 1, 0, 0],
            [0, 1, 1, 1, 1, 1, 0, 1, 0, 1],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 1, 1, 1, 1, 1, 1, 1, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        ];

        let goalPosition = {
            x: Math.floor(Math.random() * mazeSize),
            y: Math.floor(Math.random() * mazeSize)
        };

        while (goalPosition.x === 0 && goalPosition.y === 0 || maze[goalPosition.y][goalPosition.x] === 1) {
            goalPosition.x = Math.floor(Math.random() * mazeSize);
            goalPosition.y = Math.floor(Math.random() * mazeSize);
        }

        const goal = document.createElement('div');
        goal.className = 'goal';
        goal.style.left = `${goalPosition.x * cellSize}vmin`;
        goal.style.top = `${goalPosition.y * cellSize}vmin`;
        mazeContainer.appendChild(goal);

        function renderWalls() {
            for (let y = 0; y < mazeSize; y++) {
                for (let x = 0; x < mazeSize; x++) {
                    if (maze[y][x] === 1) {
                        const wall = document.createElement('div');
                        wall.className = 'wall';
                        wall.style.left = `${x * cellSize}vmin`;
                        wall.style.top = `${y * cellSize}vmin`;
                        mazeContainer.appendChild(wall);
                    }
                }
            }
        }

        function moveBall() {
            let newX = ballPosition.x + velocity.x;
            let newY = ballPosition.y + velocity.y;

            // Apply friction
            velocity.x *= friction;
            velocity.y *= friction;

            // Check for collisions with walls
            if (!isWall(newX, ballPosition.y)) {
                ballPosition.x = newX;
            } else {
                velocity.x = 0;
            }

            if (!isWall(ballPosition.x, newY)) {
                ballPosition.y = newY;
            } else {
                velocity.y = 0;
            }

            // Boundary checks
            if (ballPosition.x < 0) {
                ballPosition.x = 0;
                velocity.x = 0;
            } else if (ballPosition.x > 9) {
                ballPosition.x = 9;
                velocity.x = 0;
            }

            if (ballPosition.y < 0) {
                ballPosition.y = 0;
                velocity.y = 0;
            } else if (ballPosition.y > 9) {
                ballPosition.y = 9;
                velocity.y = 0;
            }

            ball.style.transform = `translate(${ballPosition.x * cellSize}vmin, ${ballPosition.y * cellSize}vmin)`;

            // Check if the ball reaches the goal
            if (Math.floor(ballPosition.x) === goalPosition.x && Math.floor(ballPosition.y) === goalPosition.y) {
                alert('Goal reached!');
                // Reset the ball position
                ballPosition = { x: 0, y: 0 };
                velocity = { x: 0, y: 0 };
            }

            requestAnimationFrame(moveBall);
        }

        function isWall(x, y) {
            if (x < 0 || x >= mazeSize || y < 0 || y >= mazeSize) return true;
            return maze[Math.floor(y)][Math.floor(x)] === 1;
        }

        async function initGyroscope() {
            try {
                if ('Gyroscope' in window) {
                    const permissionStatus = await navigator.permissions.query({ name: 'gyroscope' });

                    if (permissionStatus.state === 'granted') {
                        startGyroscope();
                    } else if (permissionStatus.state === 'prompt') {
                        console.log('Requesting gyroscope permission...');
                        startGyroscope();
                    } else {
                        console.log('Gyroscope permission is denied.');
                        updateUIForNoGyroscope();
                    }
                } else {
                    console.log('Gyroscope API is not supported in this browser.');
                    updateUIForNoGyroscope();
                }
            } catch (error) {
                console.error('Error initializing gyroscope:', error);
                updateUIForNoGyroscope();
            }
        }

        function startGyroscope() {
            let gyro = new Gyroscope({ frequency: 60 });
            gyro.addEventListener('reading', () => {
                velocity.x += gyro.y * sensitivity; // left-right tilt
                velocity.y += gyro.x * sensitivity; // forward-backward tilt
            });
            gyro.start();
        }

        function updateUIForNoGyroscope() {
            console.log('Gyroscope API is not supported or permission denied.');
        }

        renderWalls();
        initGyroscope();
        moveBall();
    </script>
</body>
</html>
